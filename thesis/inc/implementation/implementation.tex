

\section{Implementation}
Most of the theory behind RS and the methodology it depends on have already been introduced.
The implementation of a RS will be described in the following.
The examples will be written in a programming language called Python.
There is also some SQL code and some UML- and EER-diagrams in order to visualize the concept.

\subsection{Content based RS in-depth}
\label{sec:implementation-contentbased}
The general framework for a content-based RS is shown in figure~\ref{fig:framework-contentbasedrs}.
There are three main components a content-based RS needs.
\begin{itemize}
    \item \textbf{Content Analyzer}\\
        Since all items the RS has to work with can potentially be unstructured, a pre-process is necessary to filter relevant information.
        This will be mainly done by techniques of IR.
        The Content Analyzer aims to bring all items in a from that can be used by its successional components.
        \citep[p.~75-77]{lops:2011}
    \item \textbf{Profile Learner}\\
        When the items are in a suitable form, the Profile Learner can construct a user profile.
        In case of Rocchio's algorithm this includes to distinguish all relevant items from non-relevant.
        With the items and the users preferences the Profile Learner can build the user profile.
        In case of Rocchio, the user profile is a vector representing his attitude towards the different attributes a item may have.
        \citep[p.~75-77]{lops:2011}
    \item \textbf{Filtering Component}\\
        For each user profile the Filtering Component can find items that may match the users preferences.
        Depending on the method implemented the result can be a binary or continuous relevance judgment.
        The continuous relevance judgement is a list of ranked items.
        \citep[p.~75-77]{lops:2011}
        The RS implemented for this thesis uses the k-nearest-neighbours (kNN) classification.
        This results in a list of ranked items where the $k$ best-ranked items will be suggested to the user.
\end{itemize}


\begin{figure}[h]
    \center
    \includegraphics[scale=0.3]{inc/implementation/HighlevelContentBased}
    \caption{High level description of a content-based RS.\citep[p.~76]{lops:2011}}
    \label{fig:framework-contentbasedrs}
\end{figure}


\input{inc/implementation/contentanalyzer/contentanalyzer}
\FloatBarrier
\input{inc/implementation/profilelearner/profilelearner}
\FloatBarrier
\input{inc/implementation/filteringcomponent/filteringcomponent}
\FloatBarrier

\subsection{Recommender library}
"Recommender library" labels the whole programming code which has been written for this thesis to build programming library which is capable to create item recommendations based on Rocchio's algorithm as declared in the milestones (figure~\ref{fig:softwaremilestones})
In short it will be called "recommender.lib".
Since the previous sections already solved the goals defined by the milestones up to the library, the next bit to explain is the build library itself.

Following tasks are being managed by recommender.lib:
\begin{itemize}
    \item Add and remove products which can be recommended
    \item Create, update and remove users
    \item Make recommendations based on a user profile
\end{itemize}

\paragraph{Initialize recommender.lib}
For using recommender.lib one has to connect it to a database first.
\begin{lstlisting}[language=Python,caption={Startup of recommender.lib},label={lst:recommenderlib-startup}]
import recommender
databasepath = "./database/recommender.sqlite3"
manager = recommender.DatabaseManager(databasepath)
\end{lstlisting}

\paragraph{Insert products}
Then one can insert some products.
A product is no more but a collection of terms which describe it.
A term can be added either by \textit{Product.add\_term()} with an optional second parameter describing its frequency.
If the parameter is omitted, the terms frequency is 1.
\textit{Product} as derived class of \textit{Document} has an image\_name as special tweak which is used to store the file path of an image that represents the product.
\begin{lstlisting}[language=Python,caption={Insertion of products},label={lst:recommenderlib-product-insertion}]
product_manager = manager.get_product_manager()
p = recommender.product.Product()
p.image_name = 'image_01.png'
p.add_term('white')
p.add_term('blouse', 1)
product_manager.add_document(p)
\end{lstlisting}

\paragraph{Get product vectors}
With products added one can easily get their vectors (for example their \textit{tf-idf}-vectors).
To do so, one calls \textit{ProductVectorManager.get\_tfidf\_vector()} with the corresponding document\_id.
\textit{ProductVectorManager} also offers methods for creating \textit{tf}-, \textit{df}- and \textit{idf}-vectors.
\begin{lstlisting}[language=Python,caption={\textit{tf-idf} vector of a product},label={lst:recommenderlib-product-vector}]
pvm = manager.get_product_vector_manager()
tfidf_vector = pvm.get_tfidf_vector(1)
print(tfidf_vector.values)  # prints: (0.0, 0.0)
\end{lstlisting}

\paragraph{Add users}
As next step a user will be created.
Any user requires a user name which identifies him.
Recommender.lib however gives any user a unique id.
Methods working on users either require a \textit{user\_name} or \textit{user\_id}.
When a user is freshly created his vector will consist of numeric null.
\begin{lstlisting}[language=Python,caption={Add user},label={lst:recommenderlib-user-add}]
uvm = manager.get_user_vector_manager()
user_name = 'test_user'
uvm.create_user(user_name)
user_id = uvm.get_user_id_for_name(user_name)
user_vector = uvm.get_user_vector_for_id(user_id)
print(user_vector.values)   # prints: (0.0, 0.0)
\end{lstlisting}

\paragraph{Execute Rocchio's algorithm}
At the time there are both products available and users created one can start receiving feedback from the user.
Assuming that the user gives positive feedback towards the currently only product available the following listing will execute it.
The product will be marked as relevant and Rocchio's algorithm will be applied.
\begin{lstlisting}[language=Python,caption={Execute Rocchio's algorithm},label={lst:recommenderlib-rocchio}]
product_id = 1
uvm.set_user_preference(user_id, product_id, True)

relevant = uvm.get_relevant_document_vector_list(user_id)
non_relevant = uvm.get_non_relevant_document_vector_list(user_id)

updated_user_vector = recommender.rocchio.calculate(user_vector, relevant, non_relevant)
uvm.update_user_vector(user_id, updated_user_vector)
\end{lstlisting}

\paragraph{Finding recommendations}
Finally one can search for products which are similar to the user\_vector.
This can be done by using \textit{k-nearest-neighbours} on the list of products and a user.
As a result a list with $k$ entries will be returned.
This list represents all recommendations.
Since kNN needs a distance-function for finding the nearest neighbours one can pass either a custom one, or use one of the pre-defined ones.
Currently there are functions for calculating euclidean or hamming distance.
As this kNN-implementation returns a combination of the distance and product-vectors, the vectors may have to be extracted.
\begin{lstlisting}[language=Python,caption={Retrieving recommendations},label={lst:recommenderlib-knn}]
distance_function = recommender.vector.arithmetic.euclidean_distance
k = 3
list_of_products = pvm.get_all_vectors()
meta_recommendations = recommender.vector.arithmetic.k_nearest_neighbours(
    k,
    updated_user_vector,
    list_of_products,
    distance_function
)
recommendations = [ vector for (distance, vector) in meta_recommendations ]
\end{lstlisting}

%Umfang und Aufgaben der Lib erkl\"aren.
\subsection{Web-API}
In order to operate the library from different programming languages except from Python a \gls{web api} has been developed.
This API offers the most frequently function-calls a program utilizing recommender.lib will be using.
The online-shop introduced in section~\ref{sec:online-shop} has been written in \gls{javascript} using the \gls{web api}.
Any request received by the web api through \gls{http} will result in a result containing a \gls{json} document.
An exhaustive list of all functions offered by the \gls{web api} and their return value is available in the appendix~\ref{sec:web-api}.

\input{inc/implementation/onlineshop/onlineshop}
\FloatBarrier

\subsection{Testing and findings}
\label{sec:testing-findings}
{\color{red}TODO}
All products which were available on the online-shop 


\subsubsection{Rocchio weights}
\label{sec:rocchio-weights}
This test checks how well the algorithm can be adjusted by the weights introduced in section~\ref{sec:rocchio}.
It will be tested how many steps it takes that all recommendations include a given term and after how many more the user vector adopts to another term.
Whereas a "step" is the combination of adding a item to the list of relevant items and updating the user vector.
\\
The test-data includes 25 documents which include the term "white" which will be the first term queried.
After all recommended items include "white", the next term "black" will be queried.
56 documents include "black" as term.
There are 595 documents in the database at total consisting of 1159 terms.
The number of recommendations displayed will be 5.
\\

\noindent
The first test will use following weights:
\\
$$\alpha = 1, \beta = 0.9, \gamma = 0.1$$
\\
% id 8; id 12
After marking two items as which include "white" as term as relevant, all 5 recommendations are products with "white" as term.
\\
% 101, 103, 109, 114, 116, 119, 123, 136, 187, 199, 207, 210, 221, 223, 235, 246, 272, 292, 296, 298, 300, 303, 317, 319, 
% 326, 382, 405, 407, 
Only after choosing 53 (of 56) products all five recommendations turned to products with black as term.
\\
Even thought the recommender quickly responded to "white" as desired term, it took quite some time for it to react to the term "black".
A possible reason is, that $\alpha$ set to 1 let's the vector stick to the past.
This means, that old recommendations are hold onto more persistently.
\\

\noindent
The second test will use following weights:
\\
$$\alpha = 0.2, \beta = 0.9, \gamma = 0.1$$
Even after marking all 25 white documents as relevant Rocchio will only recommend three items containing "white" at once.
Nevertheless the recommendations quickly adopted to the term "white" and already displayed three white items after setting three white items as relevant.
\\
The same rule applies when shifting to black items.
Because $\alpha$ was set to a value too low it appears that the algorithm couldn't "remember" what the user searched for and therefore could not generate credible recommendations.
\\

\noindent
For a final test the weighting of $\alpha$ will be something in-between of test one and two:
$$\alpha = 0.6, \beta = 0.9, \gamma = 0.1$$
With $\alpha$ set to 0.6 there have been way better results achieved.
After choosing three white items all recommendations consisted of items with "white" as term.
\\
And after selecting eight black items all recommendations have turned to products consisting of the term "black".
\\

\noindent
Depending on the use-case one can adapt $\alpha$ to either make a fast-learning recommender system or one that will remember the users preferences for a long time.
With high values for $\alpha$ Rocchio's algorithm will slowly adapt to recent changes in the users mind.
A low $\alpha$ will result in way faster adaption, while the quality of recommendations may decrease.
\\

\noindent
$\gamma$ however may depend on the kind of feedback the RS expects.
\citeauthor{manning:2009} suggest that systems which only allow positive feedback (meaning that the user cannot dislike any item) should set $\gamma$ to 0.\citep[p.~183]{manning:2009}
In general following rule applies: $\beta > \gamma$.
Otherwise Rocchio's algorithm would shift the user vector close to items which he has not rated as relevant.
This would result in recommending items which are possibly disliked by the user.



\subsubsection{Final verdict}
Even thought Rocchio's algorithm has already been successfully used for information retrieval purposes in general \citep[p.~183]{manning:2009} the usage of the online-shop is not too promising yet.
There are various possible reasons.
The test data on which the algorithm worked was neither great in number, nor good in quality.
There have only been two different kinds of clothing (blouses and trousers) and those haven't even been described well enough.
Also there there a well-known problems which may cause the algorithm to result in lower quality recommendations:
\begin{itemize}
    \item Synonyms which are used through different documents/items result can heavily impact Rocchio's algorithm.
        Terms with the same meaning may be relatively far away from each other in within the vector space model.
        \citep[p.~184]{manning:2009}
        While both 'beige' and 'off-white' may describe the same color the problem is more clear for the same word in different languages such as 'white' and 'wei\ss{}'.
        This are actual examples from the data which has been used to power the build recommender system.

    \item Even thought this problem did not apply to this online shop it may happen, that words which are popular in different domains also confuse Rocchio's algorithm.
    \citep[p.~184]{manning:2009}
\end{itemize}

\noindent
When the algorithm is used on a real online-shop there are some restrictions that should be met.
Instead of tracking a user for a long time-period and successively refining his vector the algorithm should be applied new for every session.
Whereas a session is the time a user looks for one given item without leaving the online shop or starting to search for some more items.
The recommendations will get inaccurate if the user switches his focus from one one kind of item to another as done by the test when changing the search from white to black items.
If this happens, the user-vector will still contain the information about white items while he already searches for the complete opposite.
This effect can be countered by choosing a relatively low $\alpha$, but this also results in worse recommendations in general.



{\color{red}Praktischer Unterschied zwischen Hamming und euklidscher Distanz}




{
\color{red}
zu wenig produkt daten?
synonyme werden nicht erkannt.

}






{\color{red}
    \begin{itemize}
        \item wie sind die Empfehlungen des algorithmus
        \item anpassung von rocchio anhand der gewichte (fuer neue nutzer schnell lernend am anfang einer neuen Mode-Saison schnell lernend)
    \end{itemize}
}

